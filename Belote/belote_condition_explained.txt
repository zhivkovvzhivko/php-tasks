Белот
Имаме тесте карти: 7 8 9 10 J Q K A от четирите вида: ♥ ♠ ♦ ♣, като за описанието се използва масив. В играта участват 4 играчи.

Да се състави програма на php, която разбърква картите 3 пъти, а после раздава на играчите като взема последователно по 3 карти от тестето за всеки играч, след което по още 2, след това отново по 3. Картите на отделните играчи да се съхраняват в двумерен масив.

Да се определят възможните анонси за всеки играч и да се запишат по подходящ начин. Без да се гледа тип на играта (без коз..всичко коз). Както следва:

Терца - три поредни карти от един цвят (пример 7♣-8♣-9♣)

Кварта- четири поредни от един цвят (пример 10♣-J♣-Q♣-K♣)

Квинта - пет поредни от един цвят  (пример 10♣-J♣-Q♣-K♣-A♣)

Каре - четири карти от всички цветове (може да бъде една от следните: 9 10 J Q K A)

Белот - притежание на Q и K от един цвят.
------------------------------------------------------------------------------------------------------

Реално никога не съм я решавал. Но си мисля в момента, че може би за удобство ще е хубаво ако си номерирам картите. Тъй като повечето са си цифри ще е по-удобно да ги ползвам както са си. 7,8,9,10...после 11 за J, 12 за Q, 13 за K и 14 за A. Така много лесно ще мога да ги обработвам. Да речем че използваме последователност пика, купа, каро, спатия. Какво ще кажеш ако им сложим стъпка през 14 (колкото са картите) пика=+0, купа=+14, каро=+28, спатия=+42

Така за пика ще имаме цифрите от 7..14, за купа 21..28, каро 35..42 и спатия 42..49
Ако направиш операцията floor(пореден_номер-1/14) би трябвало да получиш боята 0, 1, 2, 3
А ако направиш (пореден_номер-1)%14 ще получиш индекс на картата. 
Аз бих използвал range(1,52) за да генерирам тестето карти и после array_filter за да премахна излишните $is_valid_belot_card = ($card_number%14 >= 7)

И после shuffle($cards) за да ги разбъркам
array_shift за да вземам карта и array_push за да я давам на даден играч (разбира се може да се направи и с array_slice, array_merge). 
Бих сортирал картите на даден играч за да проверя дали има последователни карти. (Например if ($card[$i] == $card[$i-1]) $ordinal++; else $ordinal=0;)
И евентуално array_count_values за да проверя за каре като му подам масив от всички карти на даден играч, но без боите им (т.е може с array_map и get_card_index - виж по-горе това с пореден_номер%14) и после с array_filter да взема всички които бройки са == 4

За визуализация бих използвал key-value масив [11=>’J’, 12=>’Q’, 13=>’K’, 14=>’A’] и да проверявам дали го имам със isset или пък може без проверката, а направо всичките да се изброят 7=>’7’ и т.н. По подобен начин ще си изброя боите и ще направя спомагателни функции.
------------------------------------------------------------------------------------------------------


Здрасти, 

Значи докато го мислех предния път нещо не съм го домислил и имам някои грешки.
Действително картите са 52, но когато започнеш да ги броиш от най-малката 2 си стават 53 (виж екселският файл). Това означава че range(2, 53) ти генерира всички карти в тестето. И заради това всички сметки трябва да се променят спрямо 2-ката. Тук малко оставам с впечатление че не разбираш добре какво прави %. Затова ще отворя една скоба и ще обясня набързо (а ако наистина имаш нужда от повече детайли - кажи).
Накратко % връща остатъка от делението и ако имаш например 7/4=1.75 всъщност е 1 с остатък 3. (или казано по друг начин е едно и 3 части от тези четири които се опитваме да разделим т.е. три четвърти) е % връща точно тая стойност 3.
Интересното е обаче друго - представи си че имаш числата 0 1 2 3 4 5 6 7 8... и т.н и докато ги печаташ на екрана искаш на всяко 3-то да слагаш нов ред. Става и с брояч, но по-лесно е с остатък от деление - виж ако за всяко едно от горните числа се приложи 0%3 1%3 2%3 3%3 и т.н. Резултатът е 0 1 2 0 1 2 0 1 2 (не е ли това мини-брояч 0..2 без да озползваш if без допълнителна променлива и без нулиране)

Да се върнем сега на картите - имаме 52 карти разпределени в 4 бои - по 13 карти от боя (броим от 0 -> 0..12). Ако искаме да вземем втората карта, от която и да е боя имаме подобна сметка  1%13 14%13 27%13 40%13 всички ще ни върнат 1. 

Какво ми помага това? Така е все още малко объркващо защото картите започват от 2
Затова формулата се променя ето така: card_value = (deck_card_value - 2) % 13 + 2
Нали стойностите са от 2 до 53. ЗА ДА започнем от нула трябва да извадим стойността на най-малката карта -2 и да вземем остатъка от деление %13 като накрая за да се запази стойността трябва да върнем обратно +2
По подобен начин можеш да вземеш индекс на боята color_index = int((deck_card_value - 2) / 13)

Забележи че нямяме map на боите, тогава може да си го решим каква да е подредбара най-накрая преди визуализация.
И така какво ми помогна това?
Ами много е лесно да превърна обратно от номер на карта в стойност на карта например 34 не знаеш какво е но card_value = 8 и color_index = 2 вече е малко по-говорещо, нали?
За това по този начин лесно ще можеш да отсееш картите, които са >= 7 само с array_filter

Остават крайните преобразувания: 
Например deck_card_value = 37 ще ни даде card_value = 11 т.е трябва да е J затова е този второстепенен map = [11=>’J’...] но това е само при визуализиране. Също и map за боите но понеже са 0..3 ще стане ето така -> [‘spases’, ‘hearts’, ‘diamonds’, ‘clubs’]

Така става ли? ;)
	------------------------------------------------------------------------------------------------------

Действително тук съм се объркал нещо. Но така е като повечето пъти пиша от телефона и не проверявам...

echo '1%13: '. 1 % 13;  // това връща 1
echo '14%13: '. 14 % 13; // това връща 1
echo '28%13: '. 28 % 13; // това връща 2
echo '42%13: '. 42 % 13; // това връща 3

Идеята е ако имаме някакъв случаен индекс карта например 17-тата от тестето да можем да я определим. Реално не я знаем каква е, но тъй като са подредени от 0 до 51 и имаме по 13 карти от боя знаем че 17 ще се падне във втората боя от редицата. Ето как са разпределени:
от 0..12 е боя 0, 
от 13..25 е боя 1 
от 26 до 38 трябва да е боя 2 и накрая 
от 39 до 51 трябва да е боя 3

Затова горните вместо 1, 14, 28 и 42 трябва да са 1, 14, 27 и 40 и така ще връща винаги 1 т.е. Втората карта от всяка боя

Но да се върнем на примера със 17
17%13=4 т.е. 5-а карта (0..4) от втората боя или ако направим проверка от списъка 2,3,4,5,6,7,9,10,J,Q,K,A-> петата карта - това е шестица (а ако сме си избрали в нашия списък боите да са ни в тая последователност: пика,купа,каро,спатия - това би трябвало да е 6-ица купа).

И така в случая:
card_value = (deck_card_value - 2) % 13 + 2
color_index = int((deck_card_value - 2) / 13)

deck_card_value = 17
card_value=6
color_index = 1

И много лесно могат да се пресметнат индексите на 6 пика, 6 каро и 6 спатия ето така:
17-13=4 (6 пика)
17+13=30 (6 каро)
17+13+13=43 (6 спатия)
*-и това само ако не съм объркал пак сметките - виж ги в таблицата за по лесно

Ако искаш поредни карти: 7, 8, 9 (терца от купи) то те ще бъдеат с индекси 18, 19, 20

Аз бих си направил няколко функции за по-лесно:
get_card_value_by_index(idx)
get_card_color_by_index(idx)
get_card_text(idx) -> idx=17, return ‘6 spades’
get_card_index(card_value, color_index) -> card_value=6, color_index=1, return 17