Сега за упражняване:
Можеш ли да обясниш как работи?

Промених $all_cards = range(2,53);
1. Създава се тесте с карти от 2 до 53 - общо 52 карти
2. В $belote_cards се филтрират картите за Белот от 2 до А - 13 карти от боя, общо 32 карти
3. Картите се разбъркват 3 пъти с shuffle()

--------------------------------------------------------------------------------------------------
Най-горе са написани помощни функции, които обработват картите.

При подаване на карта от тестето от 2 до 53(общо 52 карти) може да се изчисли:
get_card_index($card_index=34)-> Връща на каква стойност от картите отговаря подадена карта // card_index=34, return 6

get_card_color_index($card_index = 34)-> Връща на кой индекс от боите отговаря дадена карта (♠=0, ♥=1, ♦=2, ♣=3) //card_index=34, color_index=2

get_card_value_by_index($card_index=34)-> Връща стойност на карата // card_index=34 -> 8

get_card_color_by_index($card_index=34)-> Връща цвят/символ на подаден индекс(2..53) // '♠', '♥', '♦', '♣'

get_card($card_index=34)-> Връща масив с карта за Белот и боята й // card_index=34 ->[0=>8,1=>♦]

is_belote_card($card=34)-> Проверява дали подадената карта от тестето е валидна карта за Белот.

function has_ordinals($card_list, $how_many)-> Проверява дали има някаква последователност от карти за терце,кварта, квинта
1: sort($cards_list); Сортира картите
2. Във foreach-a започват да се броят картите.
2.1: Първия път никога проверката if ($card_index == $prev_card_index + 1) не минава, защото никоя карта в тестето не е равна на 1, влиза в else-a и $cnt винаги има първа стойност 1. При влизане в esle винаги $cnt=1. $cnt брои колко са последователните карти.

- След първата итерация_на_foreach/проверка_на_if на $prev_card_index се присвоята предходната карта от $card_list. Ако $prev_card_index + 1 (предходната_карта+1) НЕ е равна на $card_index(текущата) отново влиза в else и $cnt=1.
- Ако влезне в if $cnt=2 и се проверява if ($cnt == $how_many). Ако още веднъж влезне в if $cnt=3.
-- Ако броя на картите е равен на how_many(3,4 или 5) if($cnt == $how_many)/if(3==3) - влиза в if и намира най-малката карта в последователността и я добавя в масива $ordinals.
Пример: Последователни карти 34,35 и 36.
$ordinals[] = $card_index - $how_many + 1;
$ordinals[] = 36 - 3 + 1; // 34
- Ако $ordinals[] НЕ е празен
-- Картите се сортират. Взима се последната карта в масива(съдържа една карта) $idx = array_pop($ordinals); в този случай е една-34
-- Връща се създалият се масив от най-малката до най-голямата карта в последователността
	range($idx, $idx + $how_many - 1) // 34 + 3 -1
- Ако $ordinals е празен се връща false.
Коментар: Според мен в началото е добе да се сортира, защото не знаем, дали могат да бъдат подадени сортирани, но излишно се сортират след if(count($ordinals)).

function has_slots($cards_list)-> Идеята е да провери дали има 4 еднакви карти, които отговарят на определена стойност от валидните карти за Белот, ако да, трябва да намери боята на всяка карта.

- Чрез array_map('get_card_index', $cards_list) всяка карта се подава на get_card_index. Намира се индекса на всяка карта (0..12). Връща се масив с индекси на всяка карта от $cards_list. Този масив се подава на array_count_values, който намира повтарящите се индекси(брои кой индкес, колко пъти го има) и връща масив в $cards_count.
Пример: Ако са подадени 11,24,37 и 49 - всички трябва да отговарят на индекс 9(value=11).
- В $cards_count, ако за даден индекс има 4 съвпадения if($number==4), които  имат еднакъв индекс(0..12), индекса се добавя в масива $slots. // $slots[]=9;
- if(count($slots)>0) Ако има добавено число в $slots 1>0
-- Ако $slots НЕ е празен се взима добавената стойност // 9
return [$card_index, $card_index+13, $card_index+26, $card_index+39];
!!!  ---------------------------------------------------------------------------------------------  !!!

Идеята е да върне 4-те карти от всяка боя намерена карта,+13,+26 и +39 и да се получи 9,22,35 и 48, но не връща тези, защото при намиране на индекс 9 (0..12) индекс 9 отговаря на карти 11, 24, 37, 50, а те отговарят 11 от генерираното тесте.
-> Ако към намерения индекс се добави +15, +28 и +39 ще се получи очакваното, но не см добавил това в output-a/html-a, защото не съм сигурен, дали идеята е просто да се нагласи или да има някаква симетрия през 13(брой карти от боя)
- Ако не влезне в if(count($slots)>0) - ще върне false

function has_belote($cards_list)-> Проверява, дали в подадените карти има Белот Q и K
- Сортира картите
- Проверява се дали има следваща карта if (!isset($cards_list[$pos+1])). В противен случай гърми с Undefined index. Ако няма се прескача тази итерация.
- На текущата карта и на следващата се намира индекса (0..12). Ако $current_card_index=10 и $next_card_index==11 означава, че има Белот, защото индекс 10 отговаря на карти: 12,25,26 и 27(Q), а индекс 11 на карти: 13,26,39 и 52(К) от картите на тестето(2,52). Ако мине тази проверка if($current_card_index==10 && $next_card_index==11) се намира индекса на цвета на (текущата карта)$card_index (0..3) и се присвоява на $belote[].
- Ако проверката if(count($belote)) мине, картите се сортират, взима се стойността в $belote и се return-ва карта от тестето (2,53). Ако стойността в $belote е 2:
return [$card_index, $card_index+13, $card_index+26, $card_index+39]; // 2*13 + 12, 2*13 + 12 -> 38 и 39

give_cards_to_players()-> намира брой играчи и им раздава еднакъв брой карти
1. В $deal_stages предварително се декларират по колко карти ще се раздават на всеки играч $deal_stages=[3, 2, 3];
2. Сумирайки array_sum($deal_stages) се намира $max_cards_per_player // 8
3. Разделят се картите за Белот(32) на максимум карти на играч в играта и се намира $players_number

-------------------------------------------------------------------------------------------------
Можеш ли да направиш всичко в отделни функции като накрая да викаш една единствена, 
която да обединява всичко (както при refuel) и да отпечатваш единствено крайния резултат от тази функция с един echo.
- Направих я, но не знам, дали се брои, че малко игрива стана
-------------------------------------------------------------------------------------------------

Можеш ли да направиш припокриващите се редици  да не се показват
например ако имаш терца, която се съдържа в следващите кварта или  квинта да не се показва терцата а само най-голямата (кварта или квинта)
-> Събрах всички анонси в един масив и с $name = key(array_reverse($announcement)); взимам ключа на последния елемент и с max най-голямата дължина.
Глупавия начин по който опитах в началото беше
$arr = array_reverse($arr);
$key = key($arr);
$first = array_shift($arr);
-------------------------------------------------------------------------------------------------

Можеш ли да направиш друг вид подреждане, например по големина на картата, вместо по боя?
-> Предполадам, че имаш предвид, ако имам 
 8♦, 10♦, J♦, Q♦, Q♣ да стане 7♠, 7♣, 8♦, 10♦, J♦, Q♦, Q♣ A♠ - това доста го мислех, но наистина не се сещам как ще стане.

---------------------------------------------------------------------------------------------
Можеш ли да направиш разиграване на карти: примерно function throw_cards($start_from_player) което да развърти по една карта от всеки играч, при което всички да имат с една карта по-малко в списъците си?
-> Тук не се досещам
ако имам ['player1', 'player2', 'player3', 'player4'] и имам подаден player3 например как да го продължа с player4, player1 и после да се върна на player2.